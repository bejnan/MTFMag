#ifndef JUDGECOLLECTOR_H_
#define JUDGECOLLECTOR_H_

#include "../../headers/algorithms.h"
#include "../../headers/tools.h"
#include "../results.h"
#include "../database.h"
#include "data_collector.h"

#include <memory>
#include <vector>

using std::shared_ptr;

namespace Base {

/**
 * Tests algorithms with given data and count penalties for every notification
 * (user choice). With DataCollector line of input is provided to
 * AnalyseNotification function which run selected Processors from Database.
 * Another responsibility of this class is exchanging data with Database
 * instance. JudgeCollector adds new algorithms for every user and manage then,
 * including getting their results (GetResult method).
 */

class JudgeCollector {
 public:

  /**
   * Constructor initializes Tools::Judge prototype for every algorithm
   * added to test.
   * @param judge_ptr Pointer to Tools::Judge instance that will count
   * penalties for all algorithms.
   */
  JudgeCollector(shared_ptr<Tools::Judge> judge_ptr);

  /**
   * Empty destructor (nothing to handle)
   */
  virtual ~JudgeCollector();

  /**
   * Method to add new algorithms to analyse.
   * Should be used before first call of AnalyseNotification method.
   *
   * @param new_algorithm Pointer to Algorithm instance to analyse
   */
  virtual void AddAlgorithm(shared_ptr<Algorithms::Algorithm> new_algorithm);

  /**
   * Heart of testing algorithms. DataInputLine passes necessary arguments to
   * find source of notification (sender of message), run for him all algorithms
   * and judge their results.
   * @param input_line Set of informations (interaction type, source id, receiver id, timestamp) read from input
   */
  virtual void AnalyseNotification(DataProvider::DataInputLine input_line);

  /**
   * Vector of results for given user. Method used after every notification to record
   * increase of penalty.
   * @param user_id User for which methods return results
   * @return Vector of results for all algorithms that support user's choices
   */
  virtual shared_ptr<vector<Result> > GetResult(int user_id);

  /**
   * If program is in learn mode (learn flag is set to yes) no penalty is added for algorithm.
   * Default program is NOT in learn mode.
   * @param learn New value of learn flag. "Yes" means learn mode, "No" opposite.
   */
  virtual void SetLearnMode(bool learn);

 private:

  /**
   * Adds algorithm instances for new user that come out during data read.
   * Uses collection of ProcessorFactories generated by added algorithms and
   * judge initialized in constructor.
   * @param user_id Id of new user (notification source)
   */
  void AddProcessorsFromFactories(int user_id);

  /**
   * Generates new ProcessorFactory for new algorithm that was added by
   * AddAlgorithm method. Important note to clone prototype of judge initialized
   * in constructor.
   * @param algorithm Pointer to new algorithm
   * @return Pointer to ProcessorFactory generating processors representing given algorithm
   */
  shared_ptr<Tools::ProcessorFactory> GenerateProcessorFactory(
      shared_ptr<Algorithms::Algorithm> algorithm);

  /** Collection of ProcessorFactories (one factory for one algorithm) to generate processors for new users */
  vector<shared_ptr<Tools::ProcessorFactory> > processor_factories_;
  /** Pointer to Tools::Judge prototype for all processors */
  const shared_ptr<Tools::Judge> judge_prototype_for_processors_;
  int start_timestamp;
  int last_timestamp;
  bool learn_mode;

};

} /* namespace Base */

#endif /* JUDGECOLLECTOR_H_ */
